\documentclass[a4paper,12pt,twocolumn]{article}
\usepackage[spanish]{babel}
\usepackage[left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{minted}


\begin{document}
\title{Moogle!}
\author{Jocdan L. L√≥pez Mantec√≥n \\ Facultad de Matem√°ticas y Computaci√≥n, Universidad de la Habana}
\date{Julio \\ 2023}
\maketitle

\begin{abstract}
El objetivo de este proyecto es crear un motor de b√∫squeda de documentos de archivos txt
bas√°ndose en el Modelo del Espacio Vectorial para la Recuperaci√≥n de Informaci√≥n. Se realiz√≥
una revisi√≥n bibliogr√°fica previa de la cual se decidieron los siguientes procedimientos: Cada
documento se representa como un vector de sus t√©rminos en el Corpus de t√©rminos, constituido
por todas las palabras de la colecci√≥n de documentos. Como medida de la importancia de las
palabras, se recurri√≥ al factor TF-IDF. As√≠ mismo, se trata la query como un pseudo-documento
representado por su propio vector de t√©rminos del Corpus. Para la determinaci√≥n de la similitud
entre la query introducida por el usuario y los documentos de la colecci√≥n se utiliz√≥ el indicador
Similitud de Cosenos que da una medida de la distancia entre el vector query y los vectores-documento
a partir de la amplitud del √°ngulo que forman estos dos vectores en el espacio
vectorial de vectores-documento. Adem√°s, se gener√≥ un snippet para cada resultado de la
b√∫squeda y se implementaron cuatro operadores de b√∫squeda que facilitan el control sobre la
misma.
Se analizaron estructuras de datos factibles para la ejecuci√≥n del mismo donde
resaltan, adem√°s de los conocidos array<T>, las colecciones List<T> y HashSet<T>
destac√°ndose este √∫ltimo por su elevado rendimiento temporal. Tambi√©n se estudi√≥ el tipo
System.String y sus m√©todos para la generaci√≥n de Snippets y las expresiones lambda
\end{abstract}

\section*{Objetivos}
\begin{enumerate}
    \item Crear un motor de b√∫squeda de documentos en formato .txt empleando el Modelo de
    \item Espacios Vectoriales para la Recuperaci√≥n de Informaci√≥n.
    \item Generar un snippet para cada resultado de la b√∫squeda.
    \item Implementar utilidades adicionales que mejoren la calidad de la b√∫squeda y el
    control sobre la misma.
    \end{enumerate}

\section{Introducci√≥n}\label{sec:intro}

\subsection{Modelo de Espacio Vectorial para la Recuperaci√≥n de Informaci√≥n (MEV)}
El modelo de espacio vectorial es una t√©cnica est√°ndar en la los Sistemas de Recuperaci√≥n de
Informaci√≥n, consiste en representar los documentos como vectores de las palabras que los
constituyen. Se construye un vocabulario con todas las palabras de la colecci√≥n de documentos
de forma que no se repitan los t√©rminos y cada uno de estos t√©rminos representa una dimensi√≥n
del espacio. Los vectores-documento representaran la importancia de cada t√©rmino del
vocabulario en el propio documento mediante su valor de peso, as√≠ mismo la query se trata
como un pseudo-documento y se representa mediante un vector en el espacio. Luego, se
emplean indicadores de similitud para determinar que documentos son similares a otros o a una
query dada.

\subsection{Term Frequency Inverse Document Frequency (TF-IDF):}
Esta medida de peso de los t√©rminos se basa en dos medidas estad√≠sticas:
\begin{itemize}
    \item \emph{Frecuencia de t√©rminos (TF):} mide la frecuencia relativa con la que un t√©rmino aparece
    en un documento, es decir, cuantas veces aparece el t√©rmino en el documento
    (frecuencia absoluta Nw) dividido por la cantidad total (Td) de palabras del documento. La
    f√≥rmula utilizada es:
    
    \begin{center}    
    \begin{equation}
        TF_w = \frac{N_w}{T_d}
    \end{equation}
    \end{center}
    La intuici√≥n con esta medida es que los t√©rminos que aparecen m√°s veces
    probablemente sean m√°s importantes para el contenido del documento.

    \item \emph{Frecuencia inversa de documento (IDF):} Mide la importancia del t√©rmino en la colecci√≥n
    de documentos, es decir, cuantos documentos de la colecci√≥n contienen el t√©rmino.
    Se emple√≥ la f√≥rmula:
        \begin{center}
        \begin{equation}
         IDF_w = \log_2(\frac{|D|}{|d_w|})   
        \end{equation}
        \end{center}

    D√≥nde |D| es la cardinalidad de la colecci√≥n de documentos, es decir, la cantidad total
    de documentos en la colecci√≥n y |dw| es la cantidad de documentos de la colecci√≥n que
    contienen el t√©rmino. El logaritmo se utiliza para evitar asignar demasiado peso 
    a los documentos que aparecen en muchos documentos y para que los t√©rminos que aparecen
    en pocos documentos tengan un mayor peso.
    La idea que subyace esta medida es que los t√©rminos que aparecen en muchos
    documentos probablemente sean menos importantes y los que aparecen en menos
    documentos son m√°s espec√≠ficos y m√°s relevantes para la b√∫squeda
\end{itemize}

La medida TF-IDF asigna un peso a cada t√©rmino en cada documento de la colecci√≥n. El peso
de un t√©rmino se calcula multiplicando la frecuencia del t√©rmino TF por la frecuencia inversa del
documento IDF:
    \begin{center}
    \begin{equation}
        weight = TF_w * IDF_w 
    \end{equation}
    \end{center}

Una vez que se han calculado los pesos para cada t√©rmino en cada documento de la colecci√≥n
se pueden utilizar para calcular la similitud entre una query y los documentos de la colecci√≥n.
En este caso se representan los documentos como un vector de pesos y se calcula la similitud
de cosenos.

\subsection{Similitud de Cosenos:}
Es una t√©cnica utilizada en la Recuperaci√≥n de Informaci√≥n para comparar la similitud entre dos
vectores, se basa en el √°ngulo entre los mismos. Cuanto menor sea el √°ngulo, mayor ser√° la
similitud entre los vectores. La similitud de cosenos se calcula como el coseno del √°ngulo entre
los vectores mediante la f√≥rmula:
    \begin{center}
    \begin{equation}
        sim(A, B) = \frac{\overrightarrow{A} * \overrightarrow{B}}{||A|| * ||B||} 
    \end{equation}
    \end{center}

Donde A y B son los vectores que se est√°n comparando, * representa el producto punto de los
vectores, y ||A||, ||B|| representan las magnitudes de los mismos.
El producto punto entre dos vectores es la suma de los productos de los componentes
correspondientes de los vectores. La magnitud de un vector es la ra√≠z cuadrada de la suma de
los cuadrados de sus componentes. La similitud de cosenos se puede calcular directamente a
partir de los pesos de los t√©rminos en los vectores.
    
    \begin{center}
    \begin{equation}
        \overrightarrow{A} * \overrightarrow{B} = \Sigma(a_i * b_i)
    \tag*{Producto Vectorial}
    \end{equation}
    \end{center}
    
    \begin{center}
    \begin{equation}
    \tag{Norma de un vector}
        ||A|| = \sqrt{\Sigma a_i^2}
    \end{equation}
    \end{center}

\subsection{Generando el snippet:}

Para generar del snippet se decidi√≥ mostrar un subtexto del documento que contenga la palabra
de la query de mayor importancia (mayor TF-IDF). b Se extrae inicialmente un snippet con un
tama√±o de 80 caracteres alrededor de la palabra mas importante de la query con respecto al
documento y al corpus; a partir de este primer resultado seguimos tomando caracteres hasta
llegar al comienzo y al final de la oraci√≥n completa respectivamente buscando la primera
aparici√≥n de los signos de puntuaci√≥n m√°s comunes que pueden delimitar una oraci√≥n: ‚Äú ¬ø? .
; ¬°! ‚Äù

\subsection{Operadores de B√∫squeda:}
Los operadores de b√∫squeda a√±aden opciones y control sobre los resultados de la b√∫squeda.
Se escriben inmediatamente antes de la palabra sobre la cual se quiere aplicar el operador.
Para su implementaci√≥n se calcula un factor al que se nombr√≥ scoreModifier (sM) el cual es un
modificador porcentual que multiplicar√° al valor de Similitud de Cosenos entre el vector
documento y el vector query obteni√©ndose el resultado de Score final. Cada operador contribuye
(si aparece en la query) al valor final del scoreModifier.
    \begin{center}
    \begin{equation}
       sM = 1.00 + \^ ùíéùíêùíÖ + !ùíéùíêùíÖ +  *ùíéùíêùíÖ + ~ùíéùíêùíÖ 
    \end{equation}
    \end{center}

Se implementaron cuatro operadores de b√∫squeda:
\begin{enumerate}
    \item  Existe ^ : Las palabras a la que se aplica a este operador debe aparecer en los
    documentos que se muestran como resultados de la b√∫squeda. Si el documento a
    evaluar no contine la palabra-operando (a las cuales se denomin√≥ markers) se
    disminuye su score en un 100\%, en caso contrario permanece inalterado:

    \item NoExiste ! : Los marcadores de este operador no deben aparecer en los resultados de
    b√∫squeda. Si el documento contiene dicho marcador disminuye su score en 100\% en
    caso contrario permanece inalterado:

    \item Importancia *: Este operador se puede emplear N veces consecutivas al inicio de la
    palabra. Por cada vez que se utilice se incrementa el score del documento que contenga
    los marcadores de este operador en un 35\%.
        \begin{center}
        \begin{equation}
            *ùíéùíêùíÖ = N * 0.35
        \end{equation}
        \end{center}

    \item Distancia~: Este es el √∫nico operador binario, se emplea para indicar dos palabras, la
    distancia entre estas incrementa el score del documento de forma tal que a menor
    distancia mayor es el incremento. Para utilizarlo escriba primero la primera palabra y
    luego la segunda comenzando con el operador (Ej.: Harry ~vacaciones).
    Se tuvo en cuenta que el tama√±o de los distintos documentos difiere y esto podr√≠a sesgar
    dicha medida de la distancia, por ello luego de calcular la distancia entre los t√©rminos en
    caracteres, se normaliza la misma dividi√©ndola entre la cantidad total de caracteres del
    documento. La funci√≥n que caracteriza este operador es:
        \begin{center}
        \begin{equation}
            ~ùíéùíêùíÖ = 1.00 - \frac{dist(w_1,w_2)}{doc.Length}
        \end{equation}
        \end{center}
    Donde $dist(w_1, w_2)$ es la menor distancia entre las dos palabras en el
    documento y doc.Lenght es la cantidad total de caracteres del documento.
    De esta forma, si la distancia entre las palabras es peque√±a entonces el segundo t√©rmino
    de la expresi√≥n tiende a cero y el factor tiende a 1.00 (100\%); de lo contrario, si la
    distancia es grande entonces el segundo t√©rmino tiende a 1 y el factor tiende a 0%.

\end{enumerate} 

\subsection{Sugerencias:}
Se implement√≥ la funcionalidad Sugerencia basado en la Distancia de Edici√≥n o Distancia de
Levenshtein. Si alguna palabra de la query no aparece en el vocabulario del corpus y no es una
stopword entonces se calcula la distancia de edici√≥n entre dicha palabra y todos los t√©rminos
del vocabulario y sustituimos esta con la palabra del vocabulario con menor distancia de edici√≥n.
Luego se sustituye esta palabra en la query.
\subsection{Distancia de Levenshtein o distancia de Edici√≥n}
La Distancia de Levenshtein o distancia de Edici√≥n es una medida de que tan similares son dos
strings. Se define como el m√≠nimo n√∫mero de transformaciones (insertar, eliminar o remplazar)
que se necesitan para convertir uno de los strings en el otro.

\subsection{Especifiaciones de Software}
EL proyecto se desarroll√≥ en el Sistema Operativo Windows 10 Pro y fue codificado en el editor
de texto Visual Studio Code empleando C# como lenguaje de programaci√≥n y el framework
.NET SDK 7. 

\subsection{Ejecutando el proyecto}
\begin{enumerate}   
\item Aseg√∫rese de tener instalado .NET Core 7.
\item Ir al directorio del proyecto ‚ÄúMoogle Project‚Äù.
\item Copiar la base de datos (colecci√≥n de documentos en formato .txt) a la carpeta Content
\item Ejecutar en la terminal de Linux:
        make dev
    Si est√°s en Windows, desde la carpeta ra√≠z del proyecto:
    dotnet watch run --project MoogleServer
\end{enumerate}


\section{Clases Empleadas}\label{sec: classes}
\subsection{Corpus:}
 Se cre√≥ la clase Corpus, la misma representa la colecci√≥n de documentos a trav√©s
del conjunto de t√©rminos(palabras) que la componen y contiene al sistema de vectoresdocumento.
\emph{Elementos de la clase:}
\begin{enumerate}
     
    \item string[] documents;
        Contiene un listado de todos los archivos txt que se encuentran en la carpeta Content.
    \item Dictionary<string, double> idfs;
        Este diccionario le asigna a cada palabra del corpus su valor de IDF.
    \item public Dictionary<string, double> IDFs { get{return vocabulary;}}
        Propiedad que regula el acceso al campo idfs.
    \item DocumentVector[] vectorList;
        Arreglo que contiene todos los documentos de la colecci√≥n representado como vectores.
    \item HashSet<string> vocabulary;
        Conjunto que contiene todas las palabras de la colecci√≥n. Se emplea un HashSet para
        evitar repeticiones de t√©rminos y por su elevado rendimiento temporal en comparaci√≥n
        con otras estructuras de datos.
    \item public HashSet<string> Vocabulary { get{ return words;}}
        Propiedad que regula el acceso a la variable al campo vocabulary.
    \item public Corpus(string ContentPath){‚Ä¶}
        Constructor de la clase Corpus, recibe como argumento la direcci√≥n de la carpeta donde
        se almacenan los archivos txt. Procesa todos los documentos convirti√©ndolos en vectores
        a la vez que conforma el vocabulario, los IDFs y asigna los pesos a cada termino en cada
        documento.
    \item public void RankDocumentsBySimilarity(DocumentVector query){‚Ä¶}
        M√©todo que recibe una query y le asigna a cada vector-documento un valor de Score
        determinado por la Similitud de Cosenos. Este m√©todo se emplea cuando la query no
        tiene operadores de b√∫squeda.
    \item public void RankDocumentsWithOperators(DocumentVector query){‚Ä¶}
        Este m√©todo se emplea para asignar el valor de Score a cada documento cuando la
        query emplea operadores de b√∫squeda. Para cada documento aplica la funci√≥n de los
        operadores de b√∫squeda correspondientes lo que devuelve un factor que modifica el
        score (dado por similitud de cosenos) entre el documento y la query.
    \item public DocumentVector[] Ranking { get;}
        Propiedad que devuelve un arreglo de vectores-documentos organizados en orden
        decreciente, seg√∫n su valor de Score, constituido por todos los documentos cuyo score
        sea mayor que 0.
    \item public HashSet<string> stopWords { get;}
        Conjunto de las stopWords. Se decidi√≥ como stopword aquellas palabras aparezcan en
        m√°s del 85\% de los documentos.
\end{enumerate}


\subsection{DocumentVector:}
Esta clase representa a cada documento como un vector de sus t√©rminos
a la vez que contiene informaci√≥n √∫til del documento y m√©todos necesarios en la concepci√≥n
del modelo.
\emph{Elementos de la clase:}
\begin{enumerate}
    \item public string FileName {get; set; }
    Contiene el t√≠tulo del documento.
    \item public string FileText {get; private set; }
    Contiene el texto del documento.
    \item public string[] Terms{ get;}
    Vector de todas las palabras del documento (con repeticiones). Se emplea para conocer el
    tama√±o del documento en palabras, la cantidad de repeticiones de cada palabra y en otros puntos
    del proyecto como el snippet y los operadores.
    \item HashSet<string> words;
    Conjunto de todas las palabras del documento (sin repeticiones)
    \item public HashSet<string> Words { get { return this.words; } }
    Propiedad que regula el acceso al campo words.
    \item Dictionary<string, int> docTermFrequency;
    Diccionario que a cada palabra del documento le asigna su valor de frecuencia relativa.
    \item double[] weights;
    Representa el vector de coordenadas del documento en el espacio de los t√©rminos del corpus
    donde el peso esta dado por el factor TF-IDF y cada t√©rmino es una dimensi√≥n del espacio.
    \item public double Score { get; set; }
    Propiedad que contiene el valor de Score del documento con respecto a la query dada por la
    Similitud de Cosenos.
    \item double magnitude;
    Norma del vector de pesos.
    \item HashSet<int> nonZeroIndexes;
    Almacena los √≠ndices del vector con valor distinto de 0 para optimizar los c√°lculos.11. Constructor de la clase 
    DocumentVector, el texto del documento como par√°metro. Inicializa y da
    valores a otros campos de la clase.
    \item public DocumentVector(string docText) {}
    Constructor de la clase DocumentVector, el texto del documento como par√°metro. Inicializa y da
    valores a otros campos de la clase.
    \item public void SetWeightsInCorpus(HashSet<string> corpusWords,Dictionary<string, double> idfs) {}
     Recibe el vocabulario del corpus con los idf de todos los t√©rminos, inicializa el array weights que
    expresa al documento como un vector donde cada coordenada es un t√©rmino del corpus y cada
    valor es el peso dado por tf-idf.
    \item public void Normalize() {}
    Normaliza el vector dividiendo los valores por la norma.
    \item public static double Similarity(DocumentVector v1, DocumentVector v2){}
    Aplica la f√≥rmula de Similitud de Cosenos entre dos vectores.
    \item public static string[] Tokenize(string text) {}
    M√©todo para extraer los tokens del texto. Divide el texto en palabras depurando todos los
    caracteres que no sean letras o d√≠gitos y devuelve el array de palabras.
\end{enumerate}
    

\subsection{Snippet}
Snippet: Clase est√°tica que implementa un grupo de funciones para generar el
snippet.
\emph{Elementos de la clase:}
\begin{enumerate}
    \item static string documentText;
    Contiene el texto del documento.
    \item static string lowerText;
    Aplica el m√©todo ToLower() al texto.
    \item public static string GetSnippet(DocumentVector queryVector,
    DocumentVector docVector){}
    M√©todo principal de la clase. Recibe el vector de la query y el del documento y
    genera un snippet que muestra un subtexto del documento que contiene la palabra
    de mayor relevancia de la query para el texto.
    \item static string MostRelevantWord(DocumentVector queryVector,
    DocumentVector docVector)
    M√©todo de que determina la palabra de mayor relevancia de la query. Empleando
    operaciones entre conjuntos, espec√≠ficamente la intersecci√≥n, interseca las palabras de la query, 
    el documento y el vocabulario (este √∫ltimo para eliminar
    stopwords) y de las palabras resultantes determina la de mayor peso (TF*IDF).
    \item static string GetTextPieceAround(int index)
    Este m√©todo extrae un subtexto alrededor de la primera aparici√≥n en el texto de la
    palabra determinada en el paso anterior, de un tama√±o mayor o igual a 80
    caracteres.
    \item public static int GetIndexOf(string word)
    Determina el primer √≠ndice donde aparece la palabra m√°s relevante.
    \item static int SentenceBeginning(int start)
    Determina el inicio de una oraci√≥n a partir de los signos de puntuaci√≥n que pueden
    delimitar la misma.
    \item static int SentenceEnding(int start)
    Determina el fin de una oraci√≥n a partir de los signos de puntuaci√≥n que pueden
    delimitar la misma.
    \item static string MyTrim(string text)
    M√©todo que elimina los espacios en blanco innecesarios en el snippet.
\end{enumerate}

\subsection{SearchOperators}
SearchOperators: Clase est√°tica que define e implementa los operadores de
b√∫squeda.
\emph{Elementos de la clase:}
\begin{enumerate}
    \item static HashSet<char> operators = new HashSet<char>("~!^*");
    Define el conjunto de s√≠mbolos que representan los operadores.
    \item static HashSet<(string word, int count)> importanceMarkers;
    Contiene las palabras que constituyen operandos del operador Importancia (*).
    \item static HashSet<string> existenceMarkers;
    Contiene las palabras que constituyen operandos del operador Existe (^).
    \item static HashSet<string> nonExistenceMarkers;
     Contiene las palabras que constituyen operandos del operador No Existe (!).
     \item static HashSet<(string, string)> distanceMarkers;
    Contiene las palabras que constituyen operandos del operador Distancia (~).
    \item public static bool[] operationsSwitch;
    Vector booleano que regula cuales operaciones se deben realizar seg√∫n la query.
    \item public static bool QueryContainsOperators(string query);
    M√©todo para determinar si la query emplea operadores de b√∫squeda.
    \item public static void SetMarkers(string query);
    M√©todos que determina los marcadores (palabras operandos) en la query.
    \item private static string TakeWord(string input);
    Este m√©todo separa las palabras de los operadores.
    \item public static float ApplySearchOperators(DocumentVector doc);
    M√©todo principal, se encarga de implementar los operadores de b√∫squeda
\end{enumerate}

\subsection{Moogle}
Moogle: La clase est√°tica Moogle contiene los m√©todos que se ejecutan al iniciar el
proyecto y desarrollar, es el c√≥digo que gu√≠a la ejecuci√≥n del programa coordinando al
resto de las clases y m√©todos.
\emph{Elementos de la clase:}
\begin{enumerate}

\item public static Corpus corpus;
    La variable est√°tica corpus permitir√° a otras clases acceder a los elementos del
    corpus como el vocabulario, los idfs de los t√©rminos y el sistema de vectores.
\item public static void SetCorpus()
    Este m√©todo se invoca al ejecutar el proyecto. Establece el corpus y lo guarda en
    la variable est√°tica 1.
\item public static SearchResult Query(string query)
    Se invoca al presionar el bot√≥n b√∫squeda en la aplicaci√≥n. A trav√©s de este m√©todo
    se recibe la query del usuario, esta se transforma en un vector y se establece su
    similitud con cada documento, se genera el snippet y se forma el resultado final de
    la b√∫squeda
\end{enumerate}

\subsection{SearchItem}
SearchItem: Es el objeto mediante la cual se representa cada resultado de b√∫squeda,
conformada por el t√≠tulo del documento, el valor de Score y el snippet generado.

\emph{Elementos de la clase:}
\begin{enumerate}
    \item public string Title { get; private set; }
    \item public string Snippet { get; private set; }
    \item public double Score { get; private set; }
    \item public SearchItem(string title, string snippet, double score)
\end{enumerate}


\subsection{SearchItem}
SearchResult: Este objeto representa el resultado general de la b√∫squeda, es la
colecci√≥n de resultados individuales (search items). Adem√°s dentro de esta clase se
implementa la funcionalidad Sugerencia a partir de m√©todos est√°ticos.

\emph{Elementos de la clase:}
\begin{enumerate}
    \item private SearchItem[] items;
    Arreglo de SearchItem, coleccion de los resultados individuales de la b√∫squeda
    \item public SearchResult(SearchItem[] items, string suggestion="")
    Constructor de la clase, genera el resultado de la b√∫squeda
    \item public string Suggestion { get; private set; }
    Sugerencia de la busqueda
    \item public SearchResult() : this(new SearchItem[0]) {}
    Constructor alternativo empleado cuando no se obtuvieron resultados en la b√∫squeda
    \item public IEnumerable<SearchItem> Items() => this.items;
    \item public int Count { get { return this.items.Length; } }
    Propiedad que devuelve la cantidad de elementos del resultado de la b√∫squeda
    \item public static string Suggestion(DocumentVector query)
    Sugerencia de la b√∫squeda
    \item private static string MostSimilarWordInCorpus(string term)
    M√©todo para la sugerencia, encuentra,entre las palabras del corpus, la m√°s similar 
    a otra palabra dada como argumento
    \item private static int EditDistance(string s1, string s2, int m ,int n)
    Calcula la distancia de Edici√≥n entre dos strings.

\section{Desarrollo}
\subsection{Estableciendo el Corpus}
Al ejecutarse el proyecto, mediante el paso anterior, autom√°ticamente se llama al m√©todo public
static void SetCorpus() de la clase Moogle que se encarga de preprocesar la colecci√≥n de docuementos y establecer el corpus.
El corpus es una instancia de la clase Corpus, el mismo recibe en su creaci√≥n la ubicaci√≥n de
la colecci√≥n de documentos ContentPath, carga todos los archivos de este directorio que
contengan la el patr√≥n ‚Äú.txt‚Äù; inicializa el vocabulario de t√©rminos, el diccionario idfs, y el array
vectorList.
Mediante un ciclo for, para cada documento de la colecci√≥n:
\begin{enumerate}
    \item Se lee el texto del mismo mediante el m√©todo File.ReadAllText() y a partir de este crea
    un DocumentVector.
    \begin{enumerate}
        \item Las instancias de la clase documentVector reciben un texto en su constructor.
        \item Procesa el texto, dividi√©ndolo en sus tokens(palabras) mediante el m√©todo
        Tokenize()
        \item Inicializa el set de palabras del documento \emph{words} y el diccionario
        docTermFrequencies.
        \item Calcula la frecuencia de todos los t√©rminos del documento.
    \end{enumerate}
    \item Asigna el nombre del archivo a la propiedad FileName del vector utilizando el m√©todo
    GetFileName().
    \item Llena el vocabulario de t√©rminos de la colecci√≥n a√±adiendo los t√©rminos de cada
    documento. Al emplear un HashSet como estructura de datos para esta tarea se evita la
    repetici√≥n de palabras.
\end{enumerate}
    A continuaci√≥n, se calcula el idf de cada palabra eliminando las stopwords. Se consider√≥ stopword aquellas
    palabras que aparecen en m√°s del 85\% de los documentos.

\begin{minted}{csharp}
    // Calculate IDFs and remove stop words
    var stopWordThreshold = Math.Log((double)100 / 85);
    foreach (var term in this.vocabulary)
    {
        var idf = Math.Log(documents.Length / idfs[term]);
        if (idf > stopWordThreshold)
            idfs[term] = idf;
        else
        {
            stopWords.Add(term);
            idfs.Remove(term);
            vocabulary.Remove(term);
        }
    }
\end{minted}

Se inicializan y calculan los vectores de pesos de los documentos con el m√©todo
SetWeightInCorpus(), luego se normalizan los vectores de pesos, de esta forma no
tenemos que realizar este paso durante la b√∫squeda , pues para hallar la similitud solamente restar√≠a realizar el producto escalar.

\begin{center}
    \begin{equation}
    sim(A, B) = \frac{\overrightarrow{A} * \overrightarrow{B}}{||A|| * ||B||}  \rightarrow sim(A, B) = \overrightarrow{A'} * \overrightarrow{B'}
    \tag*{Producto Vectorial}
    \end{equation}
    \end{center}

Donde A' y B' son los vectores normalizados.
Luego se ejecuta la aplicaci√≥n web en el navegador predetermiando donde el usuario introduce la query y presiona el bot√≥n
b√∫squeda que invoca al m√©todo Query() de la clase Moogle. Esta toma como argumento la
query introducida por el usuario y la transforma en un DocumentVector, calcula el array de pesos
y lo normaliza. Luego calcula los scores de cada documento a partir de la similitud de cosenos.

\subsection{Operadores de B√∫squeda}
La estructura de control if nos ayuda a determinar si la query contiene o no operadores de
b√∫squedas.

\begin{minted}{csharp}
    if (SearchOperators.QueryContainsOperators(query))
    {
        SearchOperators.SetMarkers(query);
        corpus.RankDocumentsWithOperators();
    }

\end{minted}


El m√©todo booleano QueryContainsOperators(string query) crea un conjunto (HashSet) de los
caracteres de la query y lo interseca con la variable est√°tica operators que contiene los
caracteres designados para los operadores. Si la interacci√≥n es vac√≠a la query no contiene
operadores y devuelve false, en caso contrario la query contiene operadores y devuelve true.
Si la query contiene operadores se invoca el m√©todo SetMarkers (string query), este divide a la
query en palabras, creando un array y analiza mediante el ciclo for el primer car√°cter da cada
una de ellas en busca de operadores.
Se ejecuta la estructura de control Switch, con el default continue, es decir, si el primer car√°cter
no es ninguno de los operadores de b√∫squeda se pasa a la siguiente palabra de la query:

\begin{minted}{csharp}
    switch (firstChar)
    {
        case '!':
            nonExistenceMarkers = new HashSet<string>();
            nonExistenceMarkers.Add(TakeWord(term));
            operationsSwitch[0] = true;
            break;
        case '^':
            existenceMarkers = new HashSet<string>();
            existenceMarkers.Add(TakeWord(term));
            operationsSwitch[1] = true;
            break;
        case '*':
            importanceMarkers = new HashSet<(string word, int count)>();
            var word = TakeWord(term);
            var count = 1;
            for (var j = 1; j < term.Length; j++)
            {
                if (term[j] != '*') break;
                count++;
            }
            (string, int) pair = (word, count);
            importanceMarkers.Add(pair);
            operationsSwitch[2] = true;

            break;
        case '~':
            distanceMarkers = new HashSet<(string, string)>();
            var marker1 = TakeWord(queryTerms[i - 1]);
            var marker2 = TakeWord(term);
            (string, string) marker = (marker1, marker2);
            distanceMarkers.Add(marker);
            operationsSwitch[3] = true;
            break;  

        default:
            continue;
    }
\end{minted}


En caso de que primer car√°cter sea un operador: se inicializa la variable est√°tica
correspondiente al operador ver \ref{sec: classes} y se la a√±ade la palabra depurada
con el m√©todo TakeWord(), se ‚Äúactiva‚Äù el operationSwitch en la posici√≥n correspondiente.
El operationSwitch es un array de bools de cuatro elementos, uno para cada operador, cuando
el m√©todo SetMarkers encuentra un operador asigna true a la posici√≥n correspondiente al
operador en el array, esto nos ayudar√° a ¬®recordar¬® que operadores debemos calcular m√°s
adelante.
El operador * se pude emplear cualquier cantidad de veces consecutivas, por eso en su case
empleamos un ciclo for y una variable auxiliar count para contar la cantidad de veces que se
emple√≥.
Al ser binario, el operador de distancia requiere dos operandos. En este case se toma la palabra
que lo contine y la palabra anterior, se unen en una tupla y se guardan los pares de palabras
en tuplas en la variable est√°tica distanceMarkers.
Luego se procede aplicar el m√©todo RankDocumentsWithOperators(queryVector):
Empleando un ciclo for, para cada vector ‚Äì documento, cuyos scores han sido calculado
previamente seg√∫n su similitud de cosenos con la query, se le aplica un modificador que
consiste en multiplicar el score por un factor scoreModifier que se calcula con el m√©todo
ApplySearchOperators (DocumentVector doc):
Este m√©todo ‚Äúdecide‚Äù (if) que operadores se deben calcular ‚Äúpregunt√°ndole‚Äù al operationSwitch;
calcula y devuelve el scoreModifier que es la suma del aporte de cada uno de los operadores
aplicados (ver Introducci√≥n). Para ello invoca los m√©todos auxilares ApplyXOp
(DocumentVector doc) donde \emph{X} es el operador correspondiente.
    %Piece of Code

\subsection{Resultados:}    
La propiedad Ranking del corpus nos devuelve un arreglo, ordenado de forma decreciente, con
todos los vectores-documento con un score mayor que 0, todos ellos se mostraran como
resultados de la b√∫squeda, en el orden mencionado, transform√°ndolos antes a SearchItems.
Para la generaci√≥n del Snippet se llama al m√©todo Snippet.GetSnippet(queryVector, docVector),
este determina la palabra de mayor importancia(peso) de la query que aparece en el
documento,
static string MostRelevantWord(DocumentVector queryVector, DocumentVector docVector)
La ubica dentro del texto
public static int GetIndexOf(string word)
y extrae una ventana del texto alrededor de dicha palabra con el metodo static string GetTextPieceAround(int index) 

\section{}

\end{document}